try:
    import cherrypy
except ImportError:
    cherrypy = None
import splunk.entity as entity
import splunk.bundle as bundle
import splunk.pdf.pdfgen_utils as pdfgen_utils
import requests
import os
import json
from splunk.clilib.bundle_paths import make_splunkhome_path
from splunk.rest import simpleRequest

WEB_CONF_ENTITY = '/configs/conf-web'

DCE_INFO_URL = 'https://{}/{}/dce/v1alpha1/info'

TENANT_INFO_URL = 'server/scs/tenantinfo'
SCS_TOKEN_URL = '/services/authorization/scs_tokens/splunkd'

logger = pdfgen_utils.getLogger()


def is_available(session_key=None):
    """
    read the available flag from web.conf
    :param session_key:
    :return:
    """
    if cherrypy is not None and cherrypy.config is not None and 'pdfgen_is_available' in cherrypy.config:
        pdf_available = cherrypy.config.get('pdfgen_is_available')
    else:
        try:
            settings = entity.getEntity(WEB_CONF_ENTITY, 'settings', sessionKey=session_key)
            pdf_available = settings.get('pdfgen_is_available', 0)
        except Exception:
            # failed to retrieve web.conf, we assume pdf service is ready.
            pdf_available = 1
    return pdf_available


def is_studio_dashboard_scheduled_export_enabled(session_key=None):
    """
    read the enable_studio_dashboard_scheduled_export flag from web.conf
    :param session_key:
    :return Boolean:
    """
    if cherrypy is not None and cherrypy.config is not None and 'enable_studio_dashboard_scheduled_export' in cherrypy.config:
        studio_dashboard_scheduled_export_enabled = cherrypy.config.get('enable_studio_dashboard_scheduled_export')
    else:
        try:
            settings = entity.getEntity(WEB_CONF_ENTITY, 'settings', sessionKey=session_key)
            studio_dashboard_scheduled_export_enabled = settings.get('enable_studio_dashboard_scheduled_export', 0)
        except Exception:
            # failed to retrieve web.conf, we assume pdf service is ready.
            studio_dashboard_scheduled_export_enabled = 1
    return studio_dashboard_scheduled_export_enabled


def is_dce_available(session_key=None):
    """
    Make request to DCE_INFO_URL and check whether DCE server is available
    :param session_key:
    :return Boolean
    """
    scs_configuration = get_scs_configuration(session_key)
    if scs_configuration is None:
        return False
    scs_token = scs_configuration.get('scs_token')
    scs_tenant = scs_configuration.get('scs_tenant')
    scs_environment = scs_configuration.get('scs_environment')

    token = 'Bearer {}'.format(scs_token)
    headers = {'Authorization': token}

    # Just pinging the DCE service to check the status
    url = DCE_INFO_URL.format(scs_environment, scs_tenant)
    try:
        response = requests.get(
            url=url,
            headers=headers
        )
        logger.debug('pinging DCE service = {}'.format(response.json()))
    except Exception as e:
        logger.error(str(e))
        return False

    return response.status_code == 200

def get_scs_configuration(session_key=None):
    """
    Read SCS configuration from server.conf and the tenantinfo and scs_tokens endpoints
    :param session_key:
    :return Dict
    """
    server_conf = bundle.getConf('server', session_key)
    scs = server_conf.get('scs')

    if scs.get('scsTokenScriptPath') is not None:
        s3_bucket_name = server_conf.get('general').get('s3_utility_bucket_name')
        try:
            get_args = {'output_mode':'json'}
            response, content = simpleRequest(TENANT_INFO_URL, method='GET', getargs=get_args, sessionKey=session_key)
            tenant_info = json.loads(content)['entry'][0]['content']
            scs_tenant = tenant_info['tenant']
            cloud_stack = tenant_info['cloudStack']
            scs_environment = tenant_info['legacyAppHostname']

            post_args = {'output_mode':'json', 'scope':'tenant'}
            response, content = simpleRequest(SCS_TOKEN_URL, method='POST', postargs=post_args, sessionKey=session_key)
            json_body = json.loads(content)
            scs_token = json_body['entry'][0]['content']['scs_token']
        except Exception as e:
            logger.error(str(e))
            return None
    elif scs.get('dceservice.principal.token') is not None:
        scs_environment = scs.get('environment')
        scs_tenant = scs.get('tenant')
        scs_token = scs.get('dceservice.principal.token')
        cloud_stack = None
        s3_bucket_name = None
    else:
        return None

    return {
        "scs_environment": scs_environment,
        "scs_tenant": scs_tenant,
        "scs_token": scs_token,
        "cloud_stack": cloud_stack,
        "s3_bucket_name": s3_bucket_name
    }
